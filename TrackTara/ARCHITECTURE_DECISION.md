# 🏗️ Архітектурне рішення: Mock API vs Real API

## Проблема

Проект залежав від бекенду, який більше не розробляється. Потрібно продовжити розробку фронтенду без обмежень з боку бекенду, але з можливістю легко повернутися до реального API коли він буде готовий.

## Рішення

Реалізовано **Service Adapter Pattern** з автоматичним перемиканням між реальним API та мок-даними через конфігурацію.

## Архітектура

```
┌─────────────────────────────────────────────────────────┐
│                    Components / Actions                 │
│  (Використовують сервіси через ServiceFactory)          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              ServiceFactory (index.js)                  │
│  Автоматично вибирає між реальним API та моками        │
└────────────┬──────────────────────────────┬────────────┘
             │                              │
             ▼                              ▼
┌────────────────────────┐    ┌──────────────────────────┐
│   Real Services        │    │    Mock Services          │
│  (оригінальні файли)   │    │  (імітують реальні API)   │
│                        │    │                           │
│  - AuthService.js      │    │  - MockAuthService.js      │
│  - UserService.js      │    │  - MockUserService.js     │
│  - ProductService.js   │    │  - MockProductService.js   │
│  - ContainerService.js │    │  - MockContainerService.js │
│  ...                   │    │  ...                      │
└────────────────────────┘    └──────────────────────────┘
```

## Переваги

### ✅ Незалежність від бекенду
- Можна продовжувати розробку без очікування бекенду
- Тестування UI/UX без реальних API запитів

### ✅ Легке перемикання
- Одна змінна в `.env` файлі
- Не потрібно змінювати код
- Автоматичний вибір через ServiceFactory

### ✅ Збереження коду
- Всі реальні сервіси залишилися без змін
- Готові до використання коли бекенд буде готовий
- Не потрібно відновлювати код

### ✅ Однакові інтерфейси
- Моки мають ті самі методи що й реальні сервіси
- Компоненти не потребують змін
- Прозора заміна

## Як це працює

### 1. Конфігурація

```javascript
// src/utils/config/apiConfig.js
export const API_CONFIG = {
  USE_MOCK_API: import.meta.env.VITE_USE_MOCK_API === 'true',
  // ...
};
```

### 2. ServiceFactory

```javascript
// src/utils/services/ServiceFactory.js
const useMock = API_CONFIG.USE_MOCK_API;

export const AuthService = useMock ? MockAuthService : RealAuthService;
export const UserService = useMock ? MockUserService : RealUserService;
// ...
```

### 3. Використання

```javascript
// В actions або компонентах
import { AuthService, UserService } from '@/utils/services';

// Автоматично використовується правильний сервіс
await AuthService.signIn(credentials);
```

## Мок-дані

### Зберігання
- В пам'яті (in-memory)
- Скидаються при перезавантаженні сторінки
- Можна легко розширити для персистентності

### Імітація
- Затримки мережевих запитів (500ms)
- Обробка помилок
- Валідація даних

## Майбутнє

### Коли бекенд буде готовий

1. Встановити `VITE_USE_MOCK_API=false` в `.env`
2. Перезапустити dev сервер
3. Готово! Всі реальні сервіси автоматично активуються

### Розширення

Можна легко додати:
- Персистентність мок-даних (localStorage)
- Більше тестових даних
- Інші джерела даних (JSON файли, тощо)

## Висновок

Це рішення дозволяє:
- ✅ Продовжувати розробку без бекенду
- ✅ Легко перемкнутися на реальний API
- ✅ Не втратити код для бекенду
- ✅ Тестувати UI без залежності від API

**Рекомендація:** Використовуйте моки для розробки, але періодично перевіряйте з реальним API коли він доступний.

